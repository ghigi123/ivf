package IVF.TestGenerator

import IVF.Criterion.Path
import IVF.Model._
import org.chocosolver.solver.Model
import org.chocosolver.solver.search.strategy.Search
import org.chocosolver.solver.variables.IntVar

object TestGenerator {
  type Path = Vector[Int]
}

/**
  * Represents whether a path must be valid for Any or All of a path list
  */
sealed trait Required

/**
  * All paths must be valid
  */
case object All extends Required

/**
  * Any path must be valid
  */
case object Any extends Required

/**
  * Base return type for the test generator
  *
  * @see [[GeneratedTestSetError]]
  * @see [[GeneratedTestSetMap]]
  * @see [[GeneratedTestSetState]]
  */
sealed trait GeneratedTestSet {
  /**
    * Checks if this generated test set is valid
    *
    * @return
    */
  def valid: Boolean

  /**
    * Get the message error of this generated test set, if any
    *
    * @return Some(error message) if any None otherwise
    */
  def checkError: Option[String]

  /** Get the state set in a readable format
    *
    * @return
    */
  def flatten: Set[State]
}

/**
  * Represents an initial state generated by a test generator
  *
  * @param state     handled state
  * @param criterion matching TestGenerator
  */
case class GeneratedTestSetState(state: State, criterion: TestGenerator) extends GeneratedTestSet {
  override def valid: Boolean = true

  override def checkError: Option[String] = None

  override def flatten: Set[State] = Set(state)
}

/**
  * Represents an error happened during the generation for a path
  *
  * @param error     error message
  * @param criterion matching TestGenerator
  */
case class GeneratedTestSetError(error: String, criterion: TestGenerator) extends GeneratedTestSet {
  override def valid: Boolean = false

  override def checkError: Option[String] = Some(criterion.name + " -> " + error)

  override def flatten: Set[State] = Set()
}

/**
  * Represents a list of results of test generator (a list of state sets)
  *
  * @param map       generated results for every test generator of the matching map test generator
  * @param required  type of validity (Any or All)
  * @param criterion matching map test generator
  */
case class GeneratedTestSetMap(map: Map[String, GeneratedTestSet], required: Required, criterion: TestGenerator) extends GeneratedTestSet {
  override def valid: Boolean = required match {
    // This state set is valid if all its children are
    case All => map.forall {
      case (_, t) => t.valid
    }
    // This state set is valid if any of its children is
    case Any => map.exists {
      case (_, t) => t.valid
    }
  }

  override def checkError: Option[String] = required match {
    // If there is any error then propagate down the message
    case All =>
      map.mapValues(_.checkError).find {
        case (_, Some(_)) => true
        case (_, None) => false
      } match {
        case Some((k, (Some(err)))) => Some("Missing " + criterion.name + ": " + k + " -> " + err)
        case _ => None
      }
    // If there is at least one result with no error return no message
    // Else say we did not find any valid test gen result
    case Any =>
      if (map.values.map(_.checkError).exists {
        case Some(_) => false
        case None => true
      })
        None
      else Some("Unable to find any " + criterion.name)
  }

  override def flatten: Set[State] = required match {
    case All => map.values.flatMap(_.flatten).toSet
    case Any => map.values.flatMap(_.flatten).headOption match {
      case Some(state) => Set(state)
      case None => Set()
    }
  }

}


/**
  * This class enables to generate tests
  *
  * There are two types of test generators, making together a tree
  *
  *  - [[PathTestGenerator]] will provide a state given a valid path
  *  - [[TestGeneratorMap]] will provide a list of states given a list of paths (or other TestMapGenerators) with an All or Any setting : must all children be valid or one is enough ?
  *
  * See usages in Criterion.scala
  *
  * @param cfg  control flow graph
  * @param name name of this generator (used in error messages)
  */
sealed abstract class TestGenerator(val cfg: CFG, val name: String) {
  /**
    * Generate tests for a given Generator
    *
    * @return a generated test set
    */
  def generateTests(): GeneratedTestSet

  override def toString: String = name + ": "
}

case class TestGeneratorMap(override val cfg: CFG, override val name: String, required: Required, criteria: Map[String, TestGenerator]) extends TestGenerator(cfg, name) {

  override def generateTests(): GeneratedTestSet = required match {
    case All =>
      // here we just generate all children
      GeneratedTestSetMap(criteria.map {
        case (key, crit) => key -> crit.generateTests()
      }, All, this)
    // here it is a bit more subtle
    // we try to find a valid generated test set and return it when it is found
    case Any => criteria.find {
      case (_, crit) => crit.generateTests().valid
    } match {
      case Some((key, c)) => GeneratedTestSetMap(Map(key -> c.generateTests()), Any, this)
      case None => GeneratedTestSetMap(Map(), Any, this)
    }
  }

  override def toString: String = super.toString + criteria.map {
    case (key, value) => key + "->" + value.toString
  }.mkString("\n")
}

/**
  * Generate a state from a path with constraint solver
  * @param cfg  control flow graph
  * @param name name of this generator (used in error messages)
  * @param path path
  */
case class PathTestGenerator(override val cfg: CFG, override val name: String, path: TestGenerator.Path) extends TestGenerator(cfg, name) {
  def generateTests(): GeneratedTestSet = {
    // this function will build a state given a path

    // first get the path as a list of booleean constraints
    val constraints = Constraint.BuildConstraints(cfg, path)

    // build the choco model
    val model: Model = new Model()

    // then all the variables in the path are registered in the choco model and stored to be reused later
    val variables = (Map[String, IntVar]() /: constraints) {
      case (accMap, exp) =>
        (accMap /: Constraint.identifyVariables(exp)) {
          case (accMap2, tVar) => if (accMap.contains(tVar.tName))
            accMap2
          else
            accMap2 + (tVar.tName -> model.intVar(tVar.tName, -100, 100))
        }
    }

    // add a constraint for every step of the path
    constraints.foreach((exp: AST.B.Expression) => {
      val constraint = exp.toConstraintVar(model, variables).eq(model.boolVar(true))
      constraint.post()
    })

    val solver = model.getSolver

    // and ... solve. At least one variable must be defined in the program
    solver.setSearch(Search.minDomLBSearch(variables.values.toSeq: _*))
    if (solver.solve()) {
      GeneratedTestSetState(State(variables
        .filterKeys(!_.contains('_'))
        .mapValues(_.getValue)
      ), this)
    } else {
      GeneratedTestSetError("unable to solve " + constraints.filter { case AST.B.Expression.Value(true) => false case _ => true }.mkString(" & ") + " for path " + Path(path).toString, this)
    }
  }

}
